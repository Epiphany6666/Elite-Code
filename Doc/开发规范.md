# springboot 数据验证是放在Controller层还是Service层

## 规范性验证放在Controller层

例如不能为空，不能为null等基本的规范性验证。前端也验证过了，后端验证确保健壮。但其实它不属于任何业务。而且Spring boot 里面的 @Validated,@NotNull @NotBlank 校验注解也是放在Controller层的。所以规范性校验放在Controller层是大家都比较认可的。

## 业务性验证放在Service层

需要查询数据库的，比如用户名不能重复，这种校验放在service层比较合适。因为与业务挂钩了。我有可能业务需求是用户名第一个字不能重复，也有可能是用户名前两个字不能重复。

## 其他

规范是人定的，是为了使代码方便维护扩展修改。并没有任何强制规定你的代码究应该怎么写。但是规范总是好的。。。



---

# 异常处理规范

## 公司外的HTTP/API[开放接口](https://so.csdn.net/so/search?q=开放接口&spm=1001.2101.3001.7020)使用错误码表示错误

```java
// 正例：使用错误码表示错误
public Result<String> processRequest(Request request) {
    if (!validate(request)) {
        return Result.error(ErrorCode.INVALID_REQUEST);
    }
    // 处理请求...
    return Result.success(response);
}
```

## 应用内部推荐使用异常抛出

```java
// 正例：应用内部使用异常抛出
public void processInternalRequest(Request request) throws CustomException {
    if (!validate(request)) {
        throw new CustomException("Invalid request");
    }
    // 处理请求...
}

// 调用处捕获异常并处理
try {
    processInternalRequest(request);
} catch (CustomException e) {
    // 异常处理逻辑
}
```

## 跨应用间RPC调用使用Result方式封装调用结果

```java
// 正例：使用Result方式封装RPC调用结果
public Result<String> remoteMethod(Request request) {
    try {
        // 远程调用...
        return Result.success(response);
    } catch (RemoteException e) {
        return Result.error(ErrorCode.REMOTE_ERROR, "Remote call failed");
    }
}
```

通过在不同场景中选择合适的错误表示方式，可以提高[错误处理](https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782&utm_source=glcblog&spm=1001.2101.3001.7020)的标准化、可读性和可靠性。
